<!DOCTYPE html>
<html>
 <body>
  <h1>Hello</h1>
  <p>First webpage with github</p>
  </body>
  
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>First page</title>
    <link href="//cdnjs.cloudflare.com/ajax/libs/normalize/3.0.1/normalize.min.css" rel="stylesheet" data-semver="3.0.1" data-require="normalize@*" />
  </head>

  <body>
    <div id="chart"></div>
    <script data-require="d3@*" data-semver="6.0.0" src="https://d3js.org/d3.v4.min.js"></script>
    <script>
      (function(d3) {
        'use strict';

        var dataset = [
          { label: 'x', count: 5 }, 
            { label: 'd', count: 10 },
            { label: 'c', count: 30 },
            { label: 'd', count: 10 },
            { label: 'c', count: 10 },
            { label: 'v', count: 35 }
        ];

        var width = 500;
        var height = 500;
        var radius = Math.min(width, height) / 2;

        var color = d3.scaleOrdinal(d3.schemeCategory20b);

        var svg = d3.select('#chart')
          .append('svg')
          .attr('width', width)
          .attr('height', height)
          .append('g')
          .attr('transform', 'translate(' + (width / 2) + 
            ',' + (height / 2) + ')');

        var arc = d3.arc()
          .innerRadius(150)
          .outerRadius(radius);

        var pie = d3.pie()
          .value(function(d) { return d.count; })
          .sort(null);

        var path = svg.selectAll('path')
          .data(pie(dataset))
          .enter()
          .append('path')
          .attr('d', arc)
          .attr('fill', function(d, i) { 
            return color(d.data.label);
          });

      })(window.d3);
        
    </script>
  </body>

</html>

 
 
<!DOCTYPE html>
<html>
  <head>    
    <title>Bar</title>
    <script type="text/javascript" src="http://mbostock.github.com/d3/d3.js?2.1.3"></script>
    <script type="text/javascript" src="http://mbostock.github.com/d3/d3.geom.js?2.1.3"></script>
    <script type="text/javascript" src="http://mbostock.github.com/d3/d3.layout.js?2.1.3"></script>
    <style type="text/css">

        .bar rect
        .label
        {
            /*
            fill: black;
            stroke: black;
*/
        }
        .label
        {
            
            font-family: Verdana;
            font-size: 15pt;
            color: gray;
            fill-opacity: .6;
        }
        .value
        {
            font-family: Verdana;
            font-size: 11pt;
            color: gray;
            fill-opacity: .6;
        }
        .tick_label
        {
            font-size: 15pt;
            font-family: Verdana;
            color: gray;
            fill-opacity: .6;
        }
    </style>
  </head>
  <body>
      
      
      
            <h1>Test 1</h1>
            <h2>Test user per year</h2>
      
      
    <script type="text/javascript">
    var data = [{"label":"2017", "value":19}, 
            {"label":"2016", "value":56}, 
            {"label":"2015", "value":7},
            {"label":"2014", "value":77},
            {"label":"2013", "value":22},
            {"label":"2012", "value":16},
            ];
    //maximum of data you want to use
    var data_max = 80,
    //number of tickmarks to use
    num_ticks = 5,
    //margins
    left_margin = 120,
    right_margin = 120,
    top_margin = 30,
    bottom_margin = 0;
    var w = 500,                        //width
        h = 500,                        //height
        color = function(id) { return '#00b3dc' };
    var x = d3.scale.linear()
        .domain([0, data_max])
        .range([0, w - ( left_margin + right_margin ) ]),
        y = d3.scale.ordinal()
        .domain(d3.range(data.length))
        .rangeBands([bottom_margin, h - top_margin], .5);
    var chart_top = h - y.rangeBand()/10 - top_margin;
    var chart_bottom = bottom_margin + y.rangeBand()/2;
    var chart_left = left_margin;
    var chart_right = w - right_margin;
    /*
     *  Setup the SVG element and position it
     */
    var vis = d3.select("body")
        .append("svg:svg")
            .attr("width", w)
            .attr("height", h)
        .append("svg:g")
            .attr("id", "barchart")
            .attr("class", "barchart")
    //Ticks
    var rules = vis.selectAll("g.rule")
        .data(x.ticks(num_ticks))
    .enter()
        .append("svg:g")
        .attr("transform", function(d)
                {
                return "translate(" + (chart_left + x(d)) + ")";});
    rules.append("svg:line")
        .attr("class", "tick")
        .attr("y1", chart_top)
        .attr("y2", chart_top + 4)
        .attr("stroke", "black");
    rules.append("svg:text")
        .attr("class", "tick_label")
        .attr("text-anchor", "middle")
        .attr("y", chart_top)
        .text(function(d)
        {
        return d;
        });
    var bbox = vis.selectAll(".tick_label").node().getBBox();
    vis.selectAll(".tick_label")
    .attr("transform", function(d)
            {
            return "translate(0," + (bbox.height) + ")";
            });
    var bars = vis.selectAll("g.bar")
        .data(data)
    .enter()
        .append("svg:g")
            .attr("class", "bar")
            .attr("transform", function(d, i) { 
                    return "translate(0, " + y(i) + ")"; });
    bars.append("svg:rect")
        .attr("x", right_margin)
        .attr("width", function(d) {
                return (x(d.value));
                })
        .attr("height", y.rangeBand())
        .attr("fill", color(0))
        .attr("stroke", color(0));
    //Labels
    var labels = vis.selectAll("g.bar")
        .append("svg:text")
            .attr("class", "label")
            .attr("x", 0)
            .attr("text-anchor", "right")
            .text(function(d) {
                    return d.label;
                    });
    var bbox = labels.node().getBBox();
    vis.selectAll(".label")
        .attr("transform", function(d) {
                return "translate(0, " + (y.rangeBand()/2 + bbox.height/4) + ")";
                });
    labels = vis.selectAll("g.bar")
        .append("svg:text")
        .attr("class", "value")
        .attr("x", function(d)
                {
                return x(d.value) + right_margin + 10;
                })
        .attr("text-anchor", "left")
        .text(function(d)
        {
        return "" + d.value + "%";
        });
    bbox = labels.node().getBBox();
    vis.selectAll(".value")
        .attr("transform", function(d)
        {
            return "translate(0, " + (y.rangeBand()/2 + bbox.height/4) + ")";
        });
    //Axes
    vis.append("svg:line")
        .attr("class", "axes")
        .attr("x1", chart_left)
        .attr("x2", chart_left)
        .attr("y1", chart_bottom)
        .attr("y2", chart_top)
        .attr("stroke", "black");
     vis.append("svg:line")
        .attr("class", "axes")
        .attr("x1", chart_left)
        .attr("x2", chart_right)
        .attr("y1", chart_top)
        .attr("y2", chart_top)
        .attr("stroke", "black");
 
    </script>
  </body>
</html>

 
 <!DOCTYPE html>
<html>
  <head>    
    <meta http-equiv="Content-type" content="text/html; charset=utf-8">
    <title>Pie Chart with numbers </title>

    <script type="text/javascript" src="http://mbostock.github.com/d3/d3.js?2.4.5"></script>

    <!-- Source for example located at: http://bl.ocks.org/1203641 -->

    <style type="text/css">
        .slice text {
            font-size: 20pt;
            font-family: Arial;
        }   
    </style>
  </head>
  <body>
      <body>
            <h1>Test 2</h1>
            <h3>Pie with numbers and names </h3>
    <script type="text/javascript">

    var canvasWidth = 700, //width
      canvasHeight = 700,   //height
      outerRadius = 150,   //radius
      color = d3.scale.category20(); //builtin range of colors

    var dataSet = [
      {"legendLabel":"One", "magnitude":20}, 
      {"legendLabel":"Two", "magnitude":40}, 
      {"legendLabel":"Three", "magnitude":50}, 
      {"legendLabel":"Four", "magnitude":16}, 
      {"legendLabel":"Five", "magnitude":50}, 
      {"legendLabel":"Six", "magnitude":8}, 
      {"legendLabel":"Seven", "magnitude":30}];
    
    var vis = d3.select("body")
      .append("svg:svg") //create the SVG element inside the <body>
        .data([dataSet]) //associate our data with the document
        .attr("width", canvasWidth) //set the width of the canvas
        .attr("height", canvasHeight) //set the height of the canvas
        .append("svg:g") //make a group to hold our pie chart
          .attr("transform", "translate(" + 1.5*outerRadius + "," + 1.5*outerRadius + ")") // relocate center of pie to 'outerRadius,outerRadius'

    // This will create <path> elements for us using arc data...
    var arc = d3.svg.arc()
      .outerRadius(outerRadius);

    var pie = d3.layout.pie() //this will create arc data for us given a list of values
      .value(function(d) { return d.magnitude; }) // Binding each value to the pie
      .sort( function(d) { return null; } );

    // Select all <g> elements with class slice (there aren't any yet)
    var arcs = vis.selectAll("g.slice")
      // Associate the generated pie data (an array of arcs, each having startAngle,
      // endAngle and value properties) 
      .data(pie)
      // This will create <g> elements for every "extra" data element that should be associated
      // with a selection. The result is creating a <g> for every object in the data array
      .enter()
      // Create a group to hold each slice (we will have a <path> and a <text>
      // element associated with each slice)
      .append("svg:g")
      .attr("class", "slice");    //allow us to style things in the slices (like text)

    arcs.append("svg:path")
      //set the color for each slice to be chosen from the color function defined above
      .attr("fill", function(d, i) { return color(i); } )
      //this creates the actual SVG path using the associated data (pie) with the arc drawing function
      .attr("d", arc);

    // Add a legendLabel to each arc slice...
    arcs.append("svg:text")
      .attr("transform", function(d) { //set the label's origin to the center of the arc
        //we have to make sure to set these before calling arc.centroid
        d.outerRadius = outerRadius + 50; // Set Outer Coordinate
        d.innerRadius = outerRadius + 45; // Set Inner Coordinate
        return "translate(" + arc.centroid(d) + ")";
      })
      .attr("text-anchor", "middle") //center the text on it's origin
      .style("fill", "Purple")
      .style("font", "bold 12px Arial")
      .text(function(d, i) { return dataSet[i].legendLabel; }); //get the label from our original data array

    // Add a magnitude value to the larger arcs, translated to the arc centroid and rotated.
    arcs.filter(function(d) { return d.endAngle - d.startAngle > .2; }).append("svg:text")
      .attr("dy", ".35em")
      .attr("text-anchor", "middle")
      //.attr("transform", function(d) { return "translate(" + arc.centroid(d) + ")rotate(" + angle(d) + ")"; })
      .attr("transform", function(d) { //set the label's origin to the center of the arc
        //we have to make sure to set these before calling arc.centroid
        d.outerRadius = outerRadius; // Set Outer Coordinate
        d.innerRadius = outerRadius/2; // Set Inner Coordinate
        return "translate(" + arc.centroid(d) + ")rotate(" + angle(d) + ")";
      })
      .style("fill", "White")
      .style("font", "bold 12px Arial")
      .text(function(d) { return d.data.magnitude; });

    // Computes the angle of an arc, converting from radians to degrees.
    function angle(d) {
      var a = (d.startAngle + d.endAngle) * 90 / Math.PI - 90;
      return a > 90 ? a - 180 : a;
    }     
        
    </script>
  </body>
</html>
 

<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		 <body>
  		<h1>Test 3</h1>
 	
 		 </body>
		<script type="text/javascript" src="../d3/d3.v3.js"></script>
		<style type="text/css">
			/* No style rules here yet */		
		</style>
	</head>
	<body>
		<script type="text/javascript">
			//Width and height
			var w = 500;
			var h = 100;
			
			var dataset = [
							[5, 20], [480, 90], [250, 50], [100, 33], [330, 95],
							[410, 12], [475, 44], [25, 67], [85, 21], [220, 88]
						  ];
	
			//Create SVG element
			var svg = d3.select("body")
						.append("svg")
						.attr("width", w)
						.attr("height", h);
			svg.selectAll("circle")
			   .data(dataset)
			   .enter()
			   .append("circle")
			   .attr("cx", function(d) {
			   		return d[0];
			   })
			   .attr("cy", function(d) {
			   		return d[1];
			   })
			   .attr("r", function(d) {
			   		return Math.sqrt(h - d[1]);
			   });
			svg.selectAll("text")
			   .data(dataset)
			   .enter()
			   .append("text")
			   .text(function(d) {
			   		return d[0] + "," + d[1];
			   })
			   .attr("x", function(d) {
			   		return d[0];
			   })
			   .attr("y", function(d) {
			   		return d[1];
			   })
			   .attr("font-family", "sans-serif")
			   .attr("font-size", "11px")
			   .attr("fill", "red");
			
		</script>
	</body>
</html>

 <!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>D3: Zoom events</title>
	<script type="text/javascript" src="d3.js"></script>
	<style type="text/css">
		body {
			background-color: gray;
		}
		svg {
			background-color: black;
		}
	</style>
</head>
<body>

	<div id="mapContainer"></div>
	<button id="zoomIn">Zoom In</button>
	<button id="zoomOut">Zoom Out</button>

	<script type="text/javascript">
		//Globals for use later
		var countries;
		var cities;
		//Year of CO2 data to map
		var year = "2010";
		//Width and height
		var w = 500;
		var h = 300;
		//Define map projection
		var projection = d3.geo.mercator()
							   .center([ 0, 40 ])
							   .translate([ w/2, h/2 ])
							   .scale([ w/7 ]);
		//Define path generator
		var path = d3.geo.path()
						 .projection(projection);
		//
		//Configure zoom behavior
		//
		var maxZoomIn = w*2;
		var maxZoomOut = w/7;
		var zoom = d3.behavior.zoom()
			.translate( projection.translate() )
			.scale( projection.scale() )
			.scaleExtent([ maxZoomOut, maxZoomIn ])
			//Defines the on("zoom") event!  That is, what
			//to do on double-click or mousewheel roll.
			.on("zoom", function(d) {
				//Get the translate and scale values from this event
				var t = d3.event.translate;
				var s = d3.event.scale;
				
				//Update the zoom and projection objects with these
				zoom.translate(t);
				projection.translate(t).scale(s);
				
				//Recalculate paths (given new t and s values)
				countries.attr("d", path);
				//Recalculate cities (same idea)
				cities.attr("cx", function(d) {
						   return projection([d.longitude, d.latitude])[0];
					   })
					   .attr("cy", function(d) {
						   return projection([d.longitude, d.latitude])[1];
					   });
					   
			});
		//Define zoom in and out functions that we can call easily later
		var zoomIn = function() {
			var newScale = Math.min(projection.scale() * 2, maxZoomIn);
			zoomTo(newScale);
		};
		var zoomOut = function() {
			var newScale = Math.max(projection.scale() / 2, maxZoomOut);
			zoomTo(newScale);
		};
		//Define zoomTo function to which we can pass a new scale value
		zoomTo = function(newScale) {
			var t = projection.translate(),
				s = projection.scale();
			
			t[0] -= w / 2;
			t[0] *= newScale / s;
			t[0] += w / 2;
			t[1] -= h * 0.55;
			t[1] *= newScale / s;
			t[1] += h * 0.55;
			
			zoom.translate(t).scale(newScale);
			projection.translate(t).scale(newScale);
			//Finally, transition paths and circles into place
			countries.transition()
				.ease("linear")
				.delay(50)
				.duration(500)
				.attr("d", path);
			cities.transition()
				.ease("linear")
				.duration(500)
				.attr("cx", function(d) {
					return projection([d.longitude, d.latitude])[0];
				})
				.attr("cy", function(d) {
					return projection([d.longitude, d.latitude])[1];
				});
		};
		//Assign zoom button behavior
		d3.select("#zoomIn")
			.on("click", function() {
				zoomIn();
			});
		d3.select("#zoomOut")
			.on("click", function() {
				zoomOut();
			});
		//Define quantize scale to sort data values into buckets of color
		//Colors by Cynthia Brewer (colorbrewer2.org), YlOrRd
		var color = d3.scale.quantize()
							.range([ "#ffffb2", "#fecc5c", "#fd8d3c", "#f03b20", "#bd0026" ]);
		//Create SVG
		var svg = d3.select("#mapContainer")
					.append("svg")
					.attr("width", w)
					.attr("height", h);
		//Load in CO2 data
		d3.csv("data/co2/co2_emissions.csv", function(data) {
			//Set input domain for color scale
			color.domain([
				d3.min(data, function(d) { return +d[year]; }), 
				d3.max(data, function(d) { return +d[year]; })
			]);
			//Load in GeoJSON data
			d3.json("data/geo/mapshaper_output.json", function(json) {
				
				//Merge the CO2 data and GeoJSON into a single array
				//
				//Loop through once for each CO2 data value
				for (var i = 0; i < data.length; i++) {
			
					//Grab country name
					var dataCountryCode = data[i].countryCode;
					
					//Grab data value, and convert from string to float
					var dataValue = +data[i][year];
			
					//Find the corresponding country inside the GeoJSON
					for (var j = 0; j < json.features.length; j++) {
					
						//We'll check the official ISO country code
						var jsonCountryCode = json.features[j].properties.iso_a3;
			
						if (dataCountryCode == jsonCountryCode) {
					
							//Copy the data value into the GeoJSON
							json.features[j].properties.co2 = dataValue;
							
							//Stop looking through the JSON
							break;
							
						}
					}		
				}
				//Create a group to contain all the country paths.
				//This is primarily to catch zoom events, even when
				//the mouse is positioned over the ocean.
				var countriesGroup = svg.append("g")
										.attr("id", "countriesGroup")
										.call(zoom);  //Bind zoom listener to the countries group
				//Create a rectangle in the background.
				//This is purely to ensure this group fills the whole
				//SVG image, so mousewheel events are caught.
				countriesGroup.append("rect")
					.attr("x", 0)
					.attr("y", 0)
					.attr("width", w)
					.attr("height", h);
				//Bind data and create one path per GeoJSON feature
				countries = countriesGroup.selectAll("path")
				   .data(json.features)
				   .enter()
				   .append("path")
				   .attr("d", path)
				   .style("fill", function(d) {
						//Get data value
						var value = d.properties.co2;
						if (value) {
							//If value exists…
							return color(value);
						} else {
							//If value is undefined…
							return "#ccc";
						}
					});
				//Load in cities data
				d3.csv("data/cities/cities.csv", function(data) {
					
					cities = svg.selectAll("circle")
					   .data(data)
					   .enter()
					   .append("circle")
					   .attr("cx", function(d) {
						   return projection([d.longitude, d.latitude])[0];
					   })
					   .attr("cy", function(d) {
						   return projection([d.longitude, d.latitude])[1];
					   })
					   .attr("r", function(d) {
						   return Math.sqrt(+d.population / w * 0.001);
					   })
					   .style("fill", "blue")
					   .style("opacity", 0.75);
					
				});
			});  //End d3.json()
		});  //End d3.csv()
	
	</script>
</body>
</html>
